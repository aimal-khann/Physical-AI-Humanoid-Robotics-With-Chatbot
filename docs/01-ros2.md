---
id: 01-ros2
title: Chapter 1 - The Robotic Nervous System (ROS 2)
sidebar_label: ROS 2
---

Welcome to Chapter 1: The Robotic Nervous System (ROS 2). In this chapter, we delve into the fundamentals of the Robot Operating System 2 (ROS 2), a flexible framework for writing robot software. ROS 2 provides libraries and tools to help software developers create robot applications. It is widely used in research and industry due to its modular design, extensive community support, and robust communication infrastructure.

## 1.1 Introduction to ROS 2

ROS 2 builds upon the concepts of ROS 1 but with significant improvements in areas such as real-time performance, multi-robot systems, and security. It is designed to enable the creation of highly concurrent and distributed robotic applications, making it suitable for complex, real-world robotic deployments.

### ROS 2 Architecture

At its core, ROS 2 is a meta-operating system for robots. It provides a structured communication layer that abstracts away the complexities of inter-process communication, allowing developers to focus on the robot's logic.

*   **DDS (Data Distribution Service)**: Unlike ROS 1's custom TCP/IP-based communication, ROS 2 leverages DDS as its underlying communication middleware. DDS is an open international standard designed for real-time systems, offering quality-of-service (QoS) policies that allow fine-grained control over data reliability, latency, and bandwidth. This makes ROS 2 highly suitable for critical applications and heterogeneous network environments.

*   **Nodes**: The fundamental unit of computation in ROS 2. Nodes are individual processes that perform specific tasks, such as reading sensor data, controlling motors, or planning paths. They are designed to be modular and reusable.

*   **Topics**: The primary mechanism for asynchronous, many-to-many communication. Nodes publish messages to topics, and other nodes subscribe to those topics to receive data. This publish-subscribe pattern facilitates loose coupling between nodes.

*   **Services**: Used for synchronous, request-reply communication. A client node sends a request to a service server node, which processes the request and sends back a response. Services are suitable for tasks that require an immediate response, like querying sensor data or triggering a specific action.

*   **Actions**: An extension of services designed for long-running, goal-oriented tasks. An action client sends a goal to an action server, which provides continuous feedback on the goal's progress and eventually a result. Actions can be preempted or cancelled, making them ideal for tasks like navigating to a goal or performing complex manipulation sequences.

*   **Parameters**: Allow nodes to expose configurable values at runtime. Parameters can be read, set, and dynamically updated, providing flexibility without recompiling code.

## 1.2 `rclpy`: ROS 2 Client Library for Python

`rclpy` is the Python client library for ROS 2, providing a user-friendly interface to interact with all ROS 2 primitives. It allows developers to write ROS 2 nodes and applications using Python, leveraging its ease of use and rich ecosystem of libraries.

### Example: Simple Publisher Node

This example demonstrates how to create a ROS 2 node that publishes a "Hello ROS 2" message to a topic.

```python
# simple_publisher.py
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class SimplePublisher(Node):
    def __init__(self):
        super().__init__('simple_publisher')
        self.publisher_ = self.create_publisher(String, 'chatter', 10) # Topic 'chatter', QoS depth 10
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello ROS 2: {self.i}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"') # Use logger for output
        self.i += 1

def main(args=None):
    rclpy.init(args=args) # Initialize rclpy library
    simple_publisher = SimplePublisher()
    rclpy.spin(simple_publisher) # Keep node alive until shutdown
    simple_publisher.destroy_node()
    rclpy.shutdown() # Shutdown rclpy library

if __name__ == '__main__':
    main()
```

### Example: Simple Subscriber Node

This example demonstrates how to create a ROS 2 node that subscribes to the "chatter" topic and prints received messages.

```python
# simple_subscriber.py
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class SimpleSubscriber(Node):
    def __init__(self):
        super().__init__('simple_subscriber')
        self.subscription = self.create_subscription(
            String,
            'chatter',
            self.listener_callback,
            10)
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    simple_subscriber = SimpleSubscriber()
    rclpy.spin(simple_subscriber)
    simple_subscriber.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Example: Service Server and Client Node

This conceptual example outlines a service that adds two integers.

**Service Definition (`add_two_ints.srv`)**:
```
int64 a
int64 b
---
int64 sum
```

**Service Server (`add_server.py`)**:
```python
import rclpy
from rclpy.node import Node
from example_interfaces.srv import AddTwoInts # Replace with your package's srv type

class AddTwoIntsServer(Node):
    def __init__(self):
        super().__init__('add_two_ints_server')
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)
        self.get_logger().info('AddTwoInts server ready.')

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info(f'Incoming request: a={request.a}, b={request.b}. Sum={response.sum}')
        return response

def main(args=None):
    rclpy.init(args=args)
    node = AddTwoIntsServer()
    rclpy.spin(node)
    rclpy.shutdown()
```

**Service Client (`add_client.py`)**:
```python
import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy
from example_interfaces.srv import AddTwoInts # Replace with your package's srv type
import sys

class AddTwoIntsClient(Node):
    def __init__(self):
        super().__init__('add_two_ints_client')
        self.cli = self.create_client(AddTwoInts, 'add_two_ints')
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('service not available, waiting again...')
        self.req = AddTwoInts.Request()

    def send_request(self, a, b):
        self.req.a = a
        self.req.b = b
        self.future = self.cli.call_async(self.req)
        rclpy.spin_until_future_complete(self, self.future)
        return self.future.result()

def main(args=None):
    rclpy.init(args=args)
    node = AddTwoIntsClient()
    if len(sys.argv) != 3:
        node.get_logger().info('Usage: add_client A B')
        rclpy.shutdown()
        sys.exit(1)
    response = node.send_request(int(sys.argv[1]), int(sys.argv[2]))
    node.get_logger().info(f'Result of add_two_ints: {response.sum}')
    node.destroy_node()
    rclpy.shutdown()
```

## 1.3 URDF for Humanoids

Unified Robot Description Format (URDF) is an XML format for describing all elements of a robot. It is used in ROS to define the kinematic and dynamic properties of a robot, as well as its visual representation. For humanoid robots, URDF becomes quite complex due to the large number of links and joints.

### URDF Structure

A URDF file consists of:
*   **Links**: Represent the rigid bodies of the robot (e.g., torso, upper arm, forearm, hand). Each link can have visual, inertial, and collision properties.
*   **Joints**: Connect two links, defining their relative motion. Joints have a type (e.g., revolute, prismatic, fixed) and can specify limits, dynamics, and safety controllers.
*   **Transmissions**: Define the relationship between actuators (motors) and joints. Essential for controlling the robot.
*   **Gazebo Extensions**: Specific tags within URDF that allow adding Gazebo-specific properties like sensor plugins, materials, and physics parameters.

### Xacro for Modular URDFs

Writing a complex URDF by hand can be tedious and error-prone. Xacro (XML Macros) is an XML macro language that allows for more modular and readable URDFs. It enables the use of variables, math functions, and includes, making it easier to manage large robot descriptions.

### Example: Simple Humanoid Arm URDF (Expanded)

This expanded example includes more detail for a two-segment arm.

```xml
<!-- simple_humanoid_arm.urdf.xacro -->
<?xml version="1.0"?>
<robot name="simple_humanoid_arm" xmlns:xacro="http://ros.org/wiki/xacro">

  <xacro:property name="M_PI" value="3.1415926535897931" />

  <!-- Base Link -->
  <link name="base_link">
    <visual>
      <geometry><box size="0.1 0.1 0.1"/></geometry>
      <material name="blue"><color rgba="0 0 1 1"/></material>
    </visual>
    <inertial>
      <mass value="0.1"/>
      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>
    </inertial>
    <collision>
      <geometry><box size="0.1 0.1 0.1"/></geometry>
    </collision>
  </link>

  <!-- Shoulder Link -->
  <link name="shoulder_link">
    <visual>
      <geometry><cylinder length="0.2" radius="0.05"/></geometry>
      <material name="red"><color rgba="1 0 0 1"/></material>
    </visual>
    <inertial>
      <mass value="0.2"/>
      <inertia ixx="0.002" ixy="0" ixz="0" iyy="0.002" iyz="0" izz="0.001"/>
    </inertial>
    <collision>
      <geometry><cylinder length="0.2" radius="0.05"/></geometry>
    </collision>
  </link>

  <!-- Shoulder Joint -->
  <joint name="shoulder_joint" type="revolute">
    <parent link="base_link"/>
    <child link="shoulder_link"/>
    <origin xyz="0 0 0.1"/>
    <axis xyz="0 0 1"/>
    <limit lower="-${M_PI/2}" upper="${M_PI/2}" effort="10" velocity="1"/>
    <dynamics damping="0.1" friction="0.1"/>
  </joint>

  <!-- Elbow Link -->
  <link name="elbow_link">
    <visual>
      <geometry><cylinder length="0.2" radius="0.04"/></geometry>
      <material name="green"><color rgba="0 1 0 1"/></material>
    </visual>
    <inertial>
      <mass value="0.15"/>
      <inertia ixx="0.0015" ixy="0" ixz="0" iyy="0.0015" iyz="0" izz="0.0005"/>
    </inertial>
    <collision>
      <geometry><cylinder length="0.2" radius="0.04"/></geometry>
    </collision>
  </link>

  <!-- Elbow Joint -->
  <joint name="elbow_joint" type="revolute">
    <parent link="shoulder_link"/>
    <child link="elbow_link"/>
    <origin xyz="0 0 0.2"/>
    <axis xyz="0 1 0"/>
    <limit lower="0" upper="${M_PI}" effort="10" velocity="1"/>
    <dynamics damping="0.1" friction="0.1"/>
  </joint>

</robot>
```

**Note**: This is still a simplified URDF. Full humanoid URDFs involve many more joints, links, sensor definitions, and often use mesh files for realistic visuals.

## 1.4 ROS 2 Launch Files

ROS 2 launch files are Python scripts used to start and configure multiple ROS 2 nodes and other processes (like Gazebo simulations) in a coordinated manner. They are essential for managing the complexity of robotic systems, providing a declarative way to define the system's startup behavior.

### Why Use Launch Files?

*   **Orchestration**: Launch multiple nodes with a single command.
*   **Configuration**: Pass parameters to nodes, remap topics/services.
*   **Composition**: Run multiple nodes within a single process for efficiency.
*   **Conditional Execution**: Start nodes based on conditions (e.g., if a parameter is set).
*   **Environment Setup**: Set environment variables before node execution.

### Structure of a ROS 2 Launch File (Python)

ROS 2 launch files are written in Python and use a declarative style to define the actions to be performed.

```python
# my_robot_bringup.launch.py
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='my_robot_driver',
            executable='motor_controller',
            name='robot_motor_controller',
            parameters=[
                {'left_wheel_radius': 0.05},
                {'right_wheel_radius': 0.05},
            ],
            remappings=[
                ('/cmd_vel', '/robot/cmd_vel')
            ]
        ),
        Node(
            package='my_robot_driver',
            executable='sensor_publisher',
            name='robot_sensor_publisher',
            namespace='/robot', # Nodes in this namespace
            output='screen'
        ),
        # You can add more nodes or include other launch files here
    ])
```

To run this launch file:
`ros2 launch my_robot_driver my_robot_bringup.launch.py`

### Node Composition

ROS 2 allows for node composition, where multiple nodes can run within a single process. This can significantly reduce overhead and improve performance, especially when nodes share common data or resources.

```python
# composed_nodes.launch.py (Conceptual)
from launch import LaunchDescription
from launch_ros.actions import ComposableNodeContainer
from launch_ros.descriptions import ComposableNode

def generate_launch_description():
    container = ComposableNodeContainer(
            name='my_robot_container',
            namespace='',
            package='rclcpp_components',
            executable='component_container',
            composable_node_descriptions=[
                ComposableNode(
                    package='my_robot_driver',
                    plugin='my_robot_driver::MotorController', # C++ plugin example
                    name='motor_controller'),
                ComposableNode(
                    package='my_robot_driver',
                    plugin='my_robot_driver::SensorPublisher',
                    name='sensor_publisher'),
            ],
            output='screen',
    )
    return LaunchDescription([container])
```

## Exercises

1.  **Modify Publisher QoS**: Experiment with different QoS settings (e.g., `ReliabilityPolicy.RELIABLE`, `DurabilityPolicy.TRANSIENT_LOCAL`) for the `simple_publisher.py` and `simple_subscriber.py` examples. Observe how these settings affect message delivery in scenarios like late-joining subscribers.

2.  **ROS 2 Action Communication**: Implement a ROS 2 action server and client in Python for a simple "count to N" action. The client sends a goal (N), the server publishes feedback (current count), and eventually a result (final count). Include preemption logic in the server.

3.  **Complex Humanoid URDF**: Create a more complex URDF/Xacro model for a simplified humanoid torso with two arms. Include at least 3 joints per arm (shoulder, elbow, wrist) and define basic inertial and visual properties for each link. Use Xacro macros for repetitive parts.

4.  **Launch File for Multiple Nodes**: Create a ROS 2 Python launch file that starts:
    *   The `simple_publisher.py` node.
    *   The `simple_subscriber.py` node.
    *   A custom node that publishes a different message type (e.g., `geometry_msgs/msg/Twist`) to a new topic.
    *   Ensure all nodes are configured with appropriate names and (if applicable) namespaces.

5.  **Parameter Management**: Extend the `simple_publisher.py` to expose its publishing frequency as a ROS 2 parameter. Create a launch file that sets this parameter when launching the node, and then dynamically change the parameter using `ros2 param set` at runtime.

6.  **Node Composition Experiment**: If you have a C++ ROS 2 environment set up, create two simple C++ nodes (e.g., a publisher and a subscriber) as composable components. Then, create a launch file to run them as composed nodes within a single process. Compare their CPU/memory usage with running them as separate processes.