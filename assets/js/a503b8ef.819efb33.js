"use strict";(globalThis.webpackChunkai_book=globalThis.webpackChunkai_book||[]).push([[869],{8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>l});var i=r(6540);const s={},o=i.createContext(s);function t(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),i.createElement(o.Provider,{value:n},e.children)}},8921:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>p,frontMatter:()=>t,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"01-ros2","title":"Chapter 1 - The Robotic Nervous System (ROS 2)","description":"Welcome to Chapter 1: The Robotic Nervous System (ROS 2). In this chapter, we delve into the fundamentals of the Robot Operating System 2 (ROS 2), a flexible framework for writing robot software. ROS 2 provides libraries and tools to help software developers create robot applications. It is widely used in research and industry due to its modular design, extensive community support, and robust communication infrastructure.","source":"@site/docs/01-ros2.md","sourceDirName":".","slug":"/01-ros2","permalink":"/Physical-AI-Humanoid-Robotics-With-Chatbot/docs/01-ros2","draft":false,"unlisted":false,"editUrl":"https://github.com/aimal-khann/Physical-AI-Humanoid-Robotics-With-Chatbot/tree/main/docs/01-ros2.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"id":"01-ros2","title":"Chapter 1 - The Robotic Nervous System (ROS 2)","sidebar_label":"ROS 2"},"sidebar":"tutorialSidebar","previous":{"title":"Introduction","permalink":"/Physical-AI-Humanoid-Robotics-With-Chatbot/docs/"},"next":{"title":"Digital Twin","permalink":"/Physical-AI-Humanoid-Robotics-With-Chatbot/docs/02-gazebo-unity"}}');var s=r(4848),o=r(8453);const t={id:"01-ros2",title:"Chapter 1 - The Robotic Nervous System (ROS 2)",sidebar_label:"ROS 2"},l=void 0,a={},c=[{value:"1.1 Introduction to ROS 2",id:"11-introduction-to-ros-2",level:2},{value:"ROS 2 Architecture",id:"ros-2-architecture",level:3},{value:"1.2 <code>rclpy</code>: ROS 2 Client Library for Python",id:"12-rclpy-ros-2-client-library-for-python",level:2},{value:"Example: Simple Publisher Node",id:"example-simple-publisher-node",level:3},{value:"Example: Simple Subscriber Node",id:"example-simple-subscriber-node",level:3},{value:"Example: Service Server and Client Node",id:"example-service-server-and-client-node",level:3},{value:"1.3 URDF for Humanoids",id:"13-urdf-for-humanoids",level:2},{value:"URDF Structure",id:"urdf-structure",level:3},{value:"Xacro for Modular URDFs",id:"xacro-for-modular-urdfs",level:3},{value:"Example: Simple Humanoid Arm URDF (Expanded)",id:"example-simple-humanoid-arm-urdf-expanded",level:3},{value:"1.4 ROS 2 Launch Files",id:"14-ros-2-launch-files",level:2},{value:"Why Use Launch Files?",id:"why-use-launch-files",level:3},{value:"Structure of a ROS 2 Launch File (Python)",id:"structure-of-a-ros-2-launch-file-python",level:3},{value:"Node Composition",id:"node-composition",level:3},{value:"Exercises",id:"exercises",level:2}];function d(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Welcome to Chapter 1: The Robotic Nervous System (ROS 2). In this chapter, we delve into the fundamentals of the Robot Operating System 2 (ROS 2), a flexible framework for writing robot software. ROS 2 provides libraries and tools to help software developers create robot applications. It is widely used in research and industry due to its modular design, extensive community support, and robust communication infrastructure."}),"\n",(0,s.jsx)(n.h2,{id:"11-introduction-to-ros-2",children:"1.1 Introduction to ROS 2"}),"\n",(0,s.jsx)(n.p,{children:"ROS 2 builds upon the concepts of ROS 1 but with significant improvements in areas such as real-time performance, multi-robot systems, and security. It is designed to enable the creation of highly concurrent and distributed robotic applications, making it suitable for complex, real-world robotic deployments."}),"\n",(0,s.jsx)(n.h3,{id:"ros-2-architecture",children:"ROS 2 Architecture"}),"\n",(0,s.jsx)(n.p,{children:"At its core, ROS 2 is a meta-operating system for robots. It provides a structured communication layer that abstracts away the complexities of inter-process communication, allowing developers to focus on the robot's logic."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"DDS (Data Distribution Service)"}),": Unlike ROS 1's custom TCP/IP-based communication, ROS 2 leverages DDS as its underlying communication middleware. DDS is an open international standard designed for real-time systems, offering quality-of-service (QoS) policies that allow fine-grained control over data reliability, latency, and bandwidth. This makes ROS 2 highly suitable for critical applications and heterogeneous network environments."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Nodes"}),": The fundamental unit of computation in ROS 2. Nodes are individual processes that perform specific tasks, such as reading sensor data, controlling motors, or planning paths. They are designed to be modular and reusable."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Topics"}),": The primary mechanism for asynchronous, many-to-many communication. Nodes publish messages to topics, and other nodes subscribe to those topics to receive data. This publish-subscribe pattern facilitates loose coupling between nodes."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Services"}),": Used for synchronous, request-reply communication. A client node sends a request to a service server node, which processes the request and sends back a response. Services are suitable for tasks that require an immediate response, like querying sensor data or triggering a specific action."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Actions"}),": An extension of services designed for long-running, goal-oriented tasks. An action client sends a goal to an action server, which provides continuous feedback on the goal's progress and eventually a result. Actions can be preempted or cancelled, making them ideal for tasks like navigating to a goal or performing complex manipulation sequences."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameters"}),": Allow nodes to expose configurable values at runtime. Parameters can be read, set, and dynamically updated, providing flexibility without recompiling code."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"12-rclpy-ros-2-client-library-for-python",children:["1.2 ",(0,s.jsx)(n.code,{children:"rclpy"}),": ROS 2 Client Library for Python"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"rclpy"})," is the Python client library for ROS 2, providing a user-friendly interface to interact with all ROS 2 primitives. It allows developers to write ROS 2 nodes and applications using Python, leveraging its ease of use and rich ecosystem of libraries."]}),"\n",(0,s.jsx)(n.h3,{id:"example-simple-publisher-node",children:"Example: Simple Publisher Node"}),"\n",(0,s.jsx)(n.p,{children:'This example demonstrates how to create a ROS 2 node that publishes a "Hello ROS 2" message to a topic.'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# simple_publisher.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\n\r\nclass SimplePublisher(Node):\r\n    def __init__(self):\r\n        super().__init__('simple_publisher')\r\n        self.publisher_ = self.create_publisher(String, 'chatter', 10) # Topic 'chatter', QoS depth 10\r\n        timer_period = 0.5  # seconds\r\n        self.timer = self.create_timer(timer_period, self.timer_callback)\r\n        self.i = 0\r\n\r\n    def timer_callback(self):\r\n        msg = String()\r\n        msg.data = f'Hello ROS 2: {self.i}'\r\n        self.publisher_.publish(msg)\r\n        self.get_logger().info(f'Publishing: \"{msg.data}\"') # Use logger for output\r\n        self.i += 1\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args) # Initialize rclpy library\r\n    simple_publisher = SimplePublisher()\r\n    rclpy.spin(simple_publisher) # Keep node alive until shutdown\r\n    simple_publisher.destroy_node()\r\n    rclpy.shutdown() # Shutdown rclpy library\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"example-simple-subscriber-node",children:"Example: Simple Subscriber Node"}),"\n",(0,s.jsx)(n.p,{children:'This example demonstrates how to create a ROS 2 node that subscribes to the "chatter" topic and prints received messages.'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# simple_subscriber.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\n\r\nclass SimpleSubscriber(Node):\r\n    def __init__(self):\r\n        super().__init__('simple_subscriber')\r\n        self.subscription = self.create_subscription(\r\n            String,\r\n            'chatter',\r\n            self.listener_callback,\r\n            10)\r\n        self.subscription  # prevent unused variable warning\r\n\r\n    def listener_callback(self, msg):\r\n        self.get_logger().info(f'I heard: \"{msg.data}\"')\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    simple_subscriber = SimpleSubscriber()\r\n    rclpy.spin(simple_subscriber)\r\n    simple_subscriber.destroy_node()\r\n    rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"example-service-server-and-client-node",children:"Example: Service Server and Client Node"}),"\n",(0,s.jsx)(n.p,{children:"This conceptual example outlines a service that adds two integers."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:["Service Definition (",(0,s.jsx)(n.code,{children:"add_two_ints.srv"}),")"]}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"int64 a\r\nint64 b\r\n---\r\nint64 sum\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:["Service Server (",(0,s.jsx)(n.code,{children:"add_server.py"}),")"]}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom example_interfaces.srv import AddTwoInts # Replace with your package's srv type\r\n\r\nclass AddTwoIntsServer(Node):\r\n    def __init__(self):\r\n        super().__init__('add_two_ints_server')\r\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\r\n        self.get_logger().info('AddTwoInts server ready.')\r\n\r\n    def add_two_ints_callback(self, request, response):\r\n        response.sum = request.a + request.b\r\n        self.get_logger().info(f'Incoming request: a={request.a}, b={request.b}. Sum={response.sum}')\r\n        return response\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = AddTwoIntsServer()\r\n    rclpy.spin(node)\r\n    rclpy.shutdown()\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsxs)(n.strong,{children:["Service Client (",(0,s.jsx)(n.code,{children:"add_client.py"}),")"]}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy\r\nfrom example_interfaces.srv import AddTwoInts # Replace with your package's srv type\r\nimport sys\r\n\r\nclass AddTwoIntsClient(Node):\r\n    def __init__(self):\r\n        super().__init__('add_two_ints_client')\r\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\r\n        while not self.cli.wait_for_service(timeout_sec=1.0):\r\n            self.get_logger().info('service not available, waiting again...')\r\n        self.req = AddTwoInts.Request()\r\n\r\n    def send_request(self, a, b):\r\n        self.req.a = a\r\n        self.req.b = b\r\n        self.future = self.cli.call_async(self.req)\r\n        rclpy.spin_until_future_complete(self, self.future)\r\n        return self.future.result()\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = AddTwoIntsClient()\r\n    if len(sys.argv) != 3:\r\n        node.get_logger().info('Usage: add_client A B')\r\n        rclpy.shutdown()\r\n        sys.exit(1)\r\n    response = node.send_request(int(sys.argv[1]), int(sys.argv[2]))\r\n    node.get_logger().info(f'Result of add_two_ints: {response.sum}')\r\n    node.destroy_node()\r\n    rclpy.shutdown()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"13-urdf-for-humanoids",children:"1.3 URDF for Humanoids"}),"\n",(0,s.jsx)(n.p,{children:"Unified Robot Description Format (URDF) is an XML format for describing all elements of a robot. It is used in ROS to define the kinematic and dynamic properties of a robot, as well as its visual representation. For humanoid robots, URDF becomes quite complex due to the large number of links and joints."}),"\n",(0,s.jsx)(n.h3,{id:"urdf-structure",children:"URDF Structure"}),"\n",(0,s.jsx)(n.p,{children:"A URDF file consists of:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Links"}),": Represent the rigid bodies of the robot (e.g., torso, upper arm, forearm, hand). Each link can have visual, inertial, and collision properties."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Joints"}),": Connect two links, defining their relative motion. Joints have a type (e.g., revolute, prismatic, fixed) and can specify limits, dynamics, and safety controllers."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Transmissions"}),": Define the relationship between actuators (motors) and joints. Essential for controlling the robot."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Gazebo Extensions"}),": Specific tags within URDF that allow adding Gazebo-specific properties like sensor plugins, materials, and physics parameters."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"xacro-for-modular-urdfs",children:"Xacro for Modular URDFs"}),"\n",(0,s.jsx)(n.p,{children:"Writing a complex URDF by hand can be tedious and error-prone. Xacro (XML Macros) is an XML macro language that allows for more modular and readable URDFs. It enables the use of variables, math functions, and includes, making it easier to manage large robot descriptions."}),"\n",(0,s.jsx)(n.h3,{id:"example-simple-humanoid-arm-urdf-expanded",children:"Example: Simple Humanoid Arm URDF (Expanded)"}),"\n",(0,s.jsx)(n.p,{children:"This expanded example includes more detail for a two-segment arm."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- simple_humanoid_arm.urdf.xacro --\x3e\r\n<?xml version="1.0"?>\r\n<robot name="simple_humanoid_arm" xmlns:xacro="http://ros.org/wiki/xacro">\r\n\r\n  <xacro:property name="M_PI" value="3.1415926535897931" />\r\n\r\n  \x3c!-- Base Link --\x3e\r\n  <link name="base_link">\r\n    <visual>\r\n      <geometry><box size="0.1 0.1 0.1"/></geometry>\r\n      <material name="blue"><color rgba="0 0 1 1"/></material>\r\n    </visual>\r\n    <inertial>\r\n      <mass value="0.1"/>\r\n      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>\r\n    </inertial>\r\n    <collision>\r\n      <geometry><box size="0.1 0.1 0.1"/></geometry>\r\n    </collision>\r\n  </link>\r\n\r\n  \x3c!-- Shoulder Link --\x3e\r\n  <link name="shoulder_link">\r\n    <visual>\r\n      <geometry><cylinder length="0.2" radius="0.05"/></geometry>\r\n      <material name="red"><color rgba="1 0 0 1"/></material>\r\n    </visual>\r\n    <inertial>\r\n      <mass value="0.2"/>\r\n      <inertia ixx="0.002" ixy="0" ixz="0" iyy="0.002" iyz="0" izz="0.001"/>\r\n    </inertial>\r\n    <collision>\r\n      <geometry><cylinder length="0.2" radius="0.05"/></geometry>\r\n    </collision>\r\n  </link>\r\n\r\n  \x3c!-- Shoulder Joint --\x3e\r\n  <joint name="shoulder_joint" type="revolute">\r\n    <parent link="base_link"/>\r\n    <child link="shoulder_link"/>\r\n    <origin xyz="0 0 0.1"/>\r\n    <axis xyz="0 0 1"/>\r\n    <limit lower="-${M_PI/2}" upper="${M_PI/2}" effort="10" velocity="1"/>\r\n    <dynamics damping="0.1" friction="0.1"/>\r\n  </joint>\r\n\r\n  \x3c!-- Elbow Link --\x3e\r\n  <link name="elbow_link">\r\n    <visual>\r\n      <geometry><cylinder length="0.2" radius="0.04"/></geometry>\r\n      <material name="green"><color rgba="0 1 0 1"/></material>\r\n    </visual>\r\n    <inertial>\r\n      <mass value="0.15"/>\r\n      <inertia ixx="0.0015" ixy="0" ixz="0" iyy="0.0015" iyz="0" izz="0.0005"/>\r\n    </inertial>\r\n    <collision>\r\n      <geometry><cylinder length="0.2" radius="0.04"/></geometry>\r\n    </collision>\r\n  </link>\r\n\r\n  \x3c!-- Elbow Joint --\x3e\r\n  <joint name="elbow_joint" type="revolute">\r\n    <parent link="shoulder_link"/>\r\n    <child link="elbow_link"/>\r\n    <origin xyz="0 0 0.2"/>\r\n    <axis xyz="0 1 0"/>\r\n    <limit lower="0" upper="${M_PI}" effort="10" velocity="1"/>\r\n    <dynamics damping="0.1" friction="0.1"/>\r\n  </joint>\r\n\r\n</robot>\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": This is still a simplified URDF. Full humanoid URDFs involve many more joints, links, sensor definitions, and often use mesh files for realistic visuals."]}),"\n",(0,s.jsx)(n.h2,{id:"14-ros-2-launch-files",children:"1.4 ROS 2 Launch Files"}),"\n",(0,s.jsx)(n.p,{children:"ROS 2 launch files are Python scripts used to start and configure multiple ROS 2 nodes and other processes (like Gazebo simulations) in a coordinated manner. They are essential for managing the complexity of robotic systems, providing a declarative way to define the system's startup behavior."}),"\n",(0,s.jsx)(n.h3,{id:"why-use-launch-files",children:"Why Use Launch Files?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Orchestration"}),": Launch multiple nodes with a single command."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Configuration"}),": Pass parameters to nodes, remap topics/services."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Composition"}),": Run multiple nodes within a single process for efficiency."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Conditional Execution"}),": Start nodes based on conditions (e.g., if a parameter is set)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Environment Setup"}),": Set environment variables before node execution."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"structure-of-a-ros-2-launch-file-python",children:"Structure of a ROS 2 Launch File (Python)"}),"\n",(0,s.jsx)(n.p,{children:"ROS 2 launch files are written in Python and use a declarative style to define the actions to be performed."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# my_robot_bringup.launch.py\r\nfrom launch import LaunchDescription\r\nfrom launch_ros.actions import Node\r\n\r\ndef generate_launch_description():\r\n    return LaunchDescription([\r\n        Node(\r\n            package='my_robot_driver',\r\n            executable='motor_controller',\r\n            name='robot_motor_controller',\r\n            parameters=[\r\n                {'left_wheel_radius': 0.05},\r\n                {'right_wheel_radius': 0.05},\r\n            ],\r\n            remappings=[\r\n                ('/cmd_vel', '/robot/cmd_vel')\r\n            ]\r\n        ),\r\n        Node(\r\n            package='my_robot_driver',\r\n            executable='sensor_publisher',\r\n            name='robot_sensor_publisher',\r\n            namespace='/robot', # Nodes in this namespace\r\n            output='screen'\r\n        ),\r\n        # You can add more nodes or include other launch files here\r\n    ])\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To run this launch file:\r\n",(0,s.jsx)(n.code,{children:"ros2 launch my_robot_driver my_robot_bringup.launch.py"})]}),"\n",(0,s.jsx)(n.h3,{id:"node-composition",children:"Node Composition"}),"\n",(0,s.jsx)(n.p,{children:"ROS 2 allows for node composition, where multiple nodes can run within a single process. This can significantly reduce overhead and improve performance, especially when nodes share common data or resources."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# composed_nodes.launch.py (Conceptual)\r\nfrom launch import LaunchDescription\r\nfrom launch_ros.actions import ComposableNodeContainer\r\nfrom launch_ros.descriptions import ComposableNode\r\n\r\ndef generate_launch_description():\r\n    container = ComposableNodeContainer(\r\n            name='my_robot_container',\r\n            namespace='',\r\n            package='rclcpp_components',\r\n            executable='component_container',\r\n            composable_node_descriptions=[\r\n                ComposableNode(\r\n                    package='my_robot_driver',\r\n                    plugin='my_robot_driver::MotorController', # C++ plugin example\r\n                    name='motor_controller'),\r\n                ComposableNode(\r\n                    package='my_robot_driver',\r\n                    plugin='my_robot_driver::SensorPublisher',\r\n                    name='sensor_publisher'),\r\n            ],\r\n            output='screen',\r\n    )\r\n    return LaunchDescription([container])\n"})}),"\n",(0,s.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Modify Publisher QoS"}),": Experiment with different QoS settings (e.g., ",(0,s.jsx)(n.code,{children:"ReliabilityPolicy.RELIABLE"}),", ",(0,s.jsx)(n.code,{children:"DurabilityPolicy.TRANSIENT_LOCAL"}),") for the ",(0,s.jsx)(n.code,{children:"simple_publisher.py"})," and ",(0,s.jsx)(n.code,{children:"simple_subscriber.py"})," examples. Observe how these settings affect message delivery in scenarios like late-joining subscribers."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"ROS 2 Action Communication"}),': Implement a ROS 2 action server and client in Python for a simple "count to N" action. The client sends a goal (N), the server publishes feedback (current count), and eventually a result (final count). Include preemption logic in the server.']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Complex Humanoid URDF"}),": Create a more complex URDF/Xacro model for a simplified humanoid torso with two arms. Include at least 3 joints per arm (shoulder, elbow, wrist) and define basic inertial and visual properties for each link. Use Xacro macros for repetitive parts."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Launch File for Multiple Nodes"}),": Create a ROS 2 Python launch file that starts:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"simple_publisher.py"})," node."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"simple_subscriber.py"})," node."]}),"\n",(0,s.jsxs)(n.li,{children:["A custom node that publishes a different message type (e.g., ",(0,s.jsx)(n.code,{children:"geometry_msgs/msg/Twist"}),") to a new topic."]}),"\n",(0,s.jsx)(n.li,{children:"Ensure all nodes are configured with appropriate names and (if applicable) namespaces."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Parameter Management"}),": Extend the ",(0,s.jsx)(n.code,{children:"simple_publisher.py"})," to expose its publishing frequency as a ROS 2 parameter. Create a launch file that sets this parameter when launching the node, and then dynamically change the parameter using ",(0,s.jsx)(n.code,{children:"ros2 param set"})," at runtime."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Node Composition Experiment"}),": If you have a C++ ROS 2 environment set up, create two simple C++ nodes (e.g., a publisher and a subscriber) as composable components. Then, create a launch file to run them as composed nodes within a single process. Compare their CPU/memory usage with running them as separate processes."]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);